module dmdscript.RandAA;
//This is a cruedly hacked version, to allow usage of precomputed hashes.
/**An associative array implementation that uses randomized linear congruential
 * probing for collision resolution.  This has the advantage that, no matter
 * how many collisions there are in the modulus hash space, O(1) expected
 * lookup time is guaranteed as long as there are few collisions in full 32-
 * or 64-bit hash space.
 *
 * By:  David Simcha
 *
 * License:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
An associative array class that uses randomized probing and open
addressing.  K is the key type, V is the value type, storeHash
determines whether the hash of each key is stored in the array.  This
increases space requirements, but allows for faster rehashing.  By
default, the hash is stored unless the array is an array of floating point
or integer types.
*/
final class RandAA(K, V, bool storeHash = shouldStoreHash!K,
                   bool useRandom = false)
{
    /** Construct an instance of RandAA with initial size initSize.

    Params:
        initSize = determines the amount of slots pre-allocated.
    */
    @trusted pure nothrow
    this(in size_t initSize = 10)
    {
        space = getNextP2(initSize);
        mask = space - 1;
        _keys = (new K[space]).ptr;
        _vals = (new V[space]).ptr;

        static if(storeHash)
        {
            hashes = (new size_t[space+1]).ptr;
        }

        _flags = (new ubyte[space]).ptr;
    }

    ///
    @property @safe @nogc pure nothrow
    size_t length() const
    {
        return _length;
    }

    ///
    @property @trusted pure nothrow
    V[] values()
    {
        size_t i = 0;
        V[] result = new V[this._length];

        foreach(ref K k, ref V v; this)
            result[i++] = v;
        return result;
    }

    ///
    @property @trusted pure nothrow
    K[] keys()
    {
        size_t i = 0;
        K[] result = new K[this._length];

        foreach(ref K k, ref V v; this)
            result[i++] = k;
        return result;
    }

    /**
    Does not allocate.  Returns a simple forward range.
    */
    @property @safe @nogc pure nothrow
    key_range keyRange()
    {
        return key_range(this);
    }

    /**
    Does not allocate.  Returns a simple forward range.
    */
    @property @safe @nogc pure nothrow
    value_range valueRange()
    {
        return value_range(this);
    }

    ///
    @safe nothrow
    bool rehash()
    {
        if(cast(float)(_length + nDead) / space < 0.7)
        {
            return false;
        }
        reserve(space + 1);
        return true;
    }

    /**
    Throws:
        A Exception on unsuccessful key search.
    */
    @trusted
    ref auto opIndex()(in auto ref K index) inout
    {
        import std.conv : text;

        size_t i = findExisting(index, getHash(index));
        if(i == size_t.max)
        {
            throw new Exception(text("Could not find key ", index));
        }
        else
        {
            return _vals[i];
        }
    }

    /**
    Returns:
        null if index is not found.
    */
    @trusted nothrow
    inout(V)* opBinaryRight(string OP : "in")(in auto ref K index) inout
    {
        size_t i = findExisting(index, getHash(index));
        if(i == size_t.max)
        {
            return null;
        }
        else
        {
            return _vals + i;
        }
    }

    /// Hackery
    @trusted pure @nogc nothrow
    inout(V)* findExistingAlt(in ref K key, in size_t hashFull) inout
    {
        size_t pos = hashFull & mask;
        assert (pos < space);
        assert (_flags !is null);
        assert (_keys !is null);
        assert (_vals !is null);
        static if(useRandom)
            size_t rand = hashFull + 1;
        else
        {
            size_t perturb = hashFull;
            size_t i = pos;
        }

        uint flag = void;
        while(true)
        {
            flag = _flags[pos];
            static if (storeHash)
            {
                if (flag == EMPTY || (hashFull == hashes[pos] &&
                                      key == _keys[pos]))
                {
                    break;
                }
            }
            else
            {
                if (flag == EMPTY || key == _keys[pos])
                {
                    break;
                }
            }

            static if(useRandom)
            {
                rand = rand * mul + add;
                pos = (rand + hashFull) & mask;
            }
            else
            {
                i = (i * 5 + perturb + 1);
                perturb /= PERTURB_SHIFT;
                pos = i & mask;
            }
        }
        return (flag == USED) ? _vals + pos : null;
    }

    ///
    @safe nothrow
    void insertAlt(in ref K key, ref V val, in size_t hashFull)
    {
        assignNoRehashCheck(key, val, hashFull);
        rehash();
    }

    @safe nothrow
    V* insertAlt2(in ref K key, ref V val, in size_t hashFull)
    {
        auto nvp = assignNoRehashCheck2(key, val, hashFull);
        if (!rehash)
            return nvp;
        return findExistingAlt(key, hashFull);
    }

    ///
    @safe nothrow
    void opIndexAssign()(auto ref V val, auto ref K index)
    {
        assignNoRehashCheck(index, val, getHash(index));
        rehash();
    }

    /**
    Removes an element from this.  Elements *may* be removed while iterating
    via .keys.
    */
    @trusted
    ref const(V) remove()(auto ref K index)
    {
        import std.conv : text;

        size_t i = findExisting(index, getHash(index));
        if(i == size_t.max)
        {
            throw new Exception(text("Could not find key ", index));
        }
        else
        {
            _length--;
            nDead++;
            _flags[i] = REMOVED;
            return _vals[i];
        }
    }

    /// ditto
    @trusted
    void remove(in V* v)
    {
        if (v < _vals || _vals + space <= v)
            throw new Exception("the argument doesn't belong to us.");

        size_t i = v - _vals;
        _length--;
        nDead++;
        _flags[i] = REMOVED;
    }

    /**
    Iterate over keys, values in lockstep.
    */
    auto opApply(Dg)(scope Dg dg)
    {
        import std.traits : ParameterTypeTuple;
        int result;

        assert (_keys !is null);
        assert (_vals !is null);
        assert (_flags !is null);


        foreach (i, k; _keys[0..space])
        {
            if (_flags[i] == USED)
            {
                static if      (1 == ParameterTypeTuple!Dg.length)
                    result = dg(_vals[i]);
                else static if (2 == ParameterTypeTuple!Dg.length)
                    result = dg(k, _vals[i]);
                else static assert (0);
                if (result)
                    break;
            }
        }

        return result;
    }

    /**
    Allows for deleting the contents of the array manually, if supported
    by the GC.
    */
    @trusted pure nothrow
    void free()
    {
        import core.memory : GC;

        GC.free(cast(void*)this._keys);
        GC.free(cast(void*)this._vals);
        GC.free(cast(void*)this._flags);

        static if(storeHash)
        {
            GC.free(cast(void*)this.hashes);
        }
    }

    //====================================================================
private:

    // Store keys, values in parallel arrays.  This prevents us from having
    // alignment overhead and prevents the GC from scanning values if only
    // keys have pointers, or vice-versa.
    K* _keys;
    V* _vals;
    ubyte* _flags;

    static if(storeHash)
    {
        size_t* hashes;  // For fast reindexing.
    }

    size_t mask;    // easy modular 2
    size_t _length; // Logical size
    size_t space;   // Storage space
    size_t nDead;   // Number of elements removed.

    /*
    Reserve enough space for newSize elements.  Note that the rehashing
    heuristics do not guarantee that no new space will be allocated before
    newSize elements are added.
    */
    @trusted nothrow
    void reserve(size_t newSize)
    {
        scope typeof(this) newTable = new typeof(this)(newSize);

        foreach(i; 0..space)
        {
            if(_flags[i] == USED)
            {
                static if(storeHash)
                {
                    newTable.assignNoRehashCheck(_keys[i], _vals[i], hashes[i]);
                }
                else
                {
                    newTable.assignNoRehashCheck(
                        _keys[i], _vals[i], getHash(_keys[i]));
                }
            }
        }

        // Can't free _vals b/c references to it could escape.  Let GC
        // handle it.
        free;

        // foreach(ti, elem; newTable.tupleof)
        // {
        //     this.tupleof[ti] = elem;
        // }
        _keys = newTable._keys;
        _vals = newTable._vals;
        _flags = newTable._flags;
        static if (storeHash)
            hashes = newTable.hashes;
        mask = newTable.mask;
        _length = newTable._length;
        space = newTable.space;
        nDead = newTable.nDead;
    }

    //
    @trusted @nogc pure nothrow
    size_t findExisting(in ref K key, in size_t hashFull)  const
    {
        size_t pos = hashFull & mask;
        static if(useRandom)
        {
            size_t rand = hashFull + 1;
        }
        else
        {
            size_t perturb = hashFull;
            size_t i = pos;
        }

        uint flag = void;
        while(true)
        {
            flag = _flags[pos];
            static if (storeHash)
            {
                if(flag == EMPTY || (hashFull == hashes[pos] &&
                                     key == _keys[pos]))
                {
                    break;
                }
            }
            else
            {
                if(flag == EMPTY || _keys[pos] == key)
                {
                    break;
                }
            }
            static if(useRandom)
            {
                rand = rand * mul + add;
                pos = (rand + hashFull) & mask;
            }
            else
            {
                i = (i * 5 + perturb + 1);
                perturb /= PERTURB_SHIFT;
                pos = i & mask;
            }
        }
        return (flag == USED) ? pos : size_t.max;
    }

    //
    @trusted @nogc pure nothrow
    size_t findForInsert(in ref K key, in size_t hashFull) //const
    {
        size_t pos = hashFull & mask;
        static if(useRandom)
            size_t rand = hashFull + 1;
        else
        {
            size_t perturb = hashFull;
            size_t i = pos;
        }

        while(true)
        {
            static if (storeHash)
            {
                if (_flags[pos] != USED || (hashes[pos] == hashFull &&
                                           _keys[pos] == key))
                {
                    break;
                }
            }
            else
            {
                if (_flags[pos] != USED || _keys[pos] == key)
                {
                    break;
                }
            }
            static if(useRandom)
            {
                rand = rand * mul + add;
                pos = (rand + hashFull) & mask;
            }
            else
            {
                i = (i * 5 + perturb + 1);
                perturb /= PERTURB_SHIFT;
                pos = i & mask;
            }
        }

        static if (storeHash)
        {
            hashes[pos] = hashFull;
        }
        return pos;
    }

    //
    @trusted @nogc pure nothrow
    void assignNoRehashCheck(in ref K key, ref V val, in size_t hashFull)
    {
        const size_t i = findForInsert(key, hashFull);
        _vals[i] = val;
        const uint flag = _flags[i];
        if(flag != USED)
        {
            if(flag == REMOVED)
            {
                assert(0 < nDead);
                nDead--;
            }
            _length++;
            _flags[i] = USED;
            _keys[i] = key;
        }
    }

    //
    @trusted @nogc pure nothrow
    V* assignNoRehashCheck2(in ref K key, ref V val, in size_t hashFull)
    {
        const size_t i = findForInsert(key, hashFull);
        _vals[i] = val;
        const uint flag = _flags[i];
        if(flag != USED)
        {
            if(flag == REMOVED)
            {
                assert(0 < nDead);
                nDead--;
            }
            _length++;
            _flags[i] = USED;
            _keys[i] = key;
        }
        return _vals + i;
    }

    //====================================================================
private static:
    enum : ubyte
    {
        EMPTY,
        USED,
        REMOVED
    }

    // Good values for a linear congruential random number gen.  The modulus
    // is implicitly uint.max + 1, meaning that we take advantage of overflow
    // to avoid a div instruction.
    enum : size_t  { mul = 1103515245U, add = 12345U }
    enum : size_t  { PERTURB_SHIFT = 32 }

    //
    struct KeyValRange(T)
    {
        @trusted @nogc pure nothrow
        this(RandAA aa)
        {
            this.aa = aa;
            while(aa._flags[index] != USED && index < aa.space)
            {
                index++;
            }
        }

        ///
        @trusted @nogc pure nothrow
        T front()
        {
            static if      (is(T == V))
            {
                return aa._vals[index];
            }
            else static if (is(T == K))
            {
                return aa._keys[index];
            }
            else static assert(0);
        }

        ///
        @trusted @nogc pure nothrow
        void popFront()
        {
            index++;
            while(aa._flags[index] != USED && index < aa.space)
            {
                index++;
            }
        }

        ///
        @safe @nogc pure nothrow
        bool empty() const
        {
            return index == aa.space;
        }

        string toString()
        {
            import std.conv : to;
            import std.exception : assumeUnique;

            char[] ret = "[".dup;
            auto copy = this;
            foreach(elem; copy)
            {
                ret ~= to !string(elem);
                ret ~= ", ";
            }

            ret[$ - 2] = ']';
            ret = ret[0..$ - 1];
            auto retImmutable = assumeUnique(ret);
            return retImmutable;
        }

    private:
        size_t index = 0;
        RandAA aa;
    }
    //
    alias key_range = KeyValRange!K;
    //
    alias value_range = KeyValRange!V;


    // Optimized for a few special cases to avoid the virtual function call
    // to TypeInfo.getHash().
    static @trusted nothrow
    size_t getHash(in ref K key)
    {
        static if(is (Y : long) && Y.sizeof <= size_t.sizeof)
        {
            return cast(size_t)key;
        }
        else static if(is (typeof(key.toHash())))
        {
            return key.toHash();
        }
        else
        {
            return typeid(K).getHash(cast(const(void)*)&key);
        }
    }

    //
    @safe @nogc pure nothrow
    size_t getNextP2(size_t n)
    {
        // get the powerof 2 > n
        assert (n < ((cast(size_t)1) << (size_t.sizeof * 8 - 1)));
        size_t result = 16;
        while(n >= result)
        {
            result *= 2;
        }
        return result;
    }
}

//==============================================================================
private:

// It's faster to store the hash if it's expensive to compute, but
// faster not to if it's cheap to compute.
template shouldStoreHash(K)
{
    import std.traits : isFloatingPoint, isIntegral;

    enum bool shouldStoreHash = !isFloatingPoint!K && !isIntegral!K;
}

//==============================================================================
version (unittest)
{
    package auto randString(String = string)(size_t size)
    {
        import std.random : uniform;
        import std.traits : ForeachType, Unqual;
        import std.exception : assumeUnique;
        alias Char = Unqual!(ForeachType!String);
        auto buf = new Char[size];
        foreach(ref one; buf)
            one = cast(Char)uniform(0, 127);
        return buf.assumeUnique;
    }
}

unittest
{
    import std.random, std.exception, std.stdio, std.algorithm;

    // Test it out.
    string[string] builtin;
    auto myAA = new RandAA!(string, string)();

    foreach(i; 0..100_000) {
        auto myKey = randString(20);
        auto myVal = randString(20);
        builtin[myKey] = myVal;
        myAA[myKey] = myVal;
    }

    enforce(myAA.length == builtin.length);
    foreach(key; myAA.keys) {
        enforce(myAA[key] == builtin[key]);
    }

    auto keys = builtin.keys;
    randomShuffle(keys);
    foreach(toRemove; keys[0..1000]) {
        builtin.remove(toRemove);
        myAA.remove(toRemove);
    }


    myAA.rehash();
    enforce(myAA.length == builtin.length);
    foreach(k, v; builtin) {
        enforce(k in myAA);
        enforce( *(k in myAA) == v);
    }

    string[] myValues;
    foreach(val; myAA.values) {
        myValues ~= val;
    }

    string[] myKeys;
    foreach(key; myAA.keys) {
        myKeys ~= key;
    }

    auto builtinKeys = builtin.keys;
    auto builtinVals = builtin.values;
    sort(builtinVals);
    sort(builtinKeys);
    sort(myKeys);
    sort(myValues);
    enforce(myKeys == builtinKeys);
    enforce(myValues == builtinVals);

    writeln("Passed all tests about RandAA.");
}

